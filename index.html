<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="light dark">
<title>大衍筮法 · 写实分堆 · 零偏差版</title>
<meta name="description" content="严格还原：三变一爻（分二→挂一→按四取余，余0记4），六爻成卦；模4均匀；WebCrypto离散零偏差；显示64卦卦名；含‘指南/解卦（朱熹）’；‘已成爻’自下而上显示。">
<style>
  :root{
    --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --line:#111; --accent:#111; --ok:#065f46; --warn:#b45309;
    --code-bg:#f7f7f7; --code-fg:#111; --code-border:#e5e7eb; --chip-border:#d1d5db;
    --tip-bg:#f8fafc; --tip-border:#e5e7eb;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",Arial}
  .wrap{max-width:1100px;margin:0 auto;padding:24px}
  h1{font-size:22px;margin:0 0 8px}

  .row{display:grid;gap:16px;grid-template-columns:1fr}
  @media(min-width:980px){.row{grid-template-columns:1.2fr 0.8fr}}
  .card{background:var(--card);border:1px solid #e5e7eb;border-radius:14px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}

  .btn{cursor:pointer;border:none;background:var(--accent);color:#fff;padding:10px 14px;border-radius:10px}
  .btn.secondary{background:#11111110;color:var(--fg);border:1px solid #00000020}
  .btn.ghost{background:transparent;border:1px dashed #00000030;color:var(--fg)}
  .btn.small{padding:6px 10px;font-size:13px;border-radius:8px}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .btn.prominent{padding:12px 16px;border-radius:12px;font-weight:600;box-shadow:0 1px 0 rgba(0,0,0,.08)}
  .btn.prominent:disabled{opacity:.65}
  #methodBtn:disabled{opacity:.45; filter:saturate(.75)}

  .muted{color:var(--muted)} .small{font-size:12px} .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,"Courier New",monospace}
  .grid2{display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:700px){.grid2{grid-template-columns:1fr 1fr}}

  .kpi{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px}
  .pill{background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;padding:4px 8px;font-size:12px}
  .pill.dim{background:transparent;border-style:dashed;color:var(--muted);opacity:.8}

  .lines{display:flex;flex-direction:column;gap:8px}
  .lines.bottom-up{flex-direction:column-reverse}
  .one-line{display:flex;align-items:center;gap:10px}
  .yang,.yin{position:relative;height:8px;width:220px}
  .yang::before{content:"";position:absolute;inset:0;background:var(--line);border-radius:2px}
  .yin{display:flex;justify-content:space-between;align-items:center}
  .yin .seg{height:8px;background:var(--line);width:44%} .yin .gap{width:12%}
  .tag{font-size:12px;color:#fff;background:#111;border-radius:6px;padding:1px 6px;margin-left:6px}
  .ok{color:var(--ok)} .warn{color:var(--warn)}
  pre{
    white-space:pre-wrap;font-size:12px;font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,"Courier New",monospace;
    background:var(--code-bg);color:var(--code-fg);border:1px solid var(--code-border);
    border-radius:10px;padding:10px;overflow:auto;line-height:1.6;max-height:44vh;word-break:break-word;
  }
  a.linkchip{display:inline-block;margin:6px 6px 0 0;padding:5px 9px;border-radius:999px;border:1px solid var(--chip-border);background:#fff;color:#111;text-decoration:none;font-size:12px}
  a.linkchip:hover{box-shadow:0 1px 0 rgba(0,0,0,.08)}

  .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:50}
  .modal > .box{max-width:760px;margin:7vh auto;background:#fff;border-radius:12px;padding:16px;outline:none}
  .modal .title{font-weight:600;margin-bottom:8px}
  .hr{height:1px;background:#e5e7eb;margin:10px 0}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
  .toolbar .sep{flex:1}
  .checkbox{display:inline-flex;gap:6px;align-items:center;font-size:12px}
  details.hint{margin-top:12px;background:#f8fafc;border:1px solid #e5e7eb;border-radius:10px;padding:10px}
  details.hint>summary{cursor:pointer;outline:none}

  .ai-tip{margin-top:8px;background:var(--tip-bg);border:1px dashed var(--tip-border);border-radius:10px;padding:8px 10px}

  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0b0b0b; --fg:#eee; --muted:#9ca3af; --card:#111; --line:#e5e7eb; --accent:#e5e7eb;
      --code-bg:#0f0f0f; --code-fg:#e5e7eb; --code-border:#222; --chip-border:#2a2a2a;
      --tip-bg:#0f1113; --tip-border:#222;
    }
    .card{ border-color:#222 }
    .btn{ background:var(--accent); color:#111; }
    .btn.secondary,.btn.ghost{ background:#ffffff10; border-color:#ffffff30; color:var(--fg); }
    .pill{ background:#1a1a1a; border-color:#2a2a2a; color:var(--fg); }
    .pill.dim{ background:transparent; border-color:#2a2a2a; color:var(--muted); }
    input,select,textarea{ background:#0f0f0f; color:var(--fg); border:1px solid #2a2a2a; border-radius:10px; padding:8px 10px; }
    .modal > .box{ background:#111; color:var(--fg); }
    .hr{ background:#222 }
    a.linkchip{ background:#1a1a1a; border-color:#2a2a2a; color:#e5e7eb; }
    details.hint{ background:#0f1113; border-color:#222; }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>大衍筮法 · 写实分堆</h1>

  <div class="row">
    <!-- 左：交互 -->
    <div class="card" aria-label="交互与过程">

      <!-- KPI：淡化 -->
      <div class="kpi">
        <div class="pill dim">模式：写实分堆（模4均匀）</div>
        <div class="pill dim">RNG：WebCrypto 离散零偏差</div>
        <div class="pill dim">VRS：<span class="mono" id="vrs">—</span></div>
        <div class="pill dim">版本：<span class="mono" id="verpill">—</span></div>
      </div>

      <!-- 控制区 -->
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px" role="group" aria-label="交互控制">
        <button class="btn prominent" id="guideBtn" aria-haspopup="dialog" aria-controls="guideModal">指南</button>

        <button class="btn" id="startHex">开始一卦</button>
        <button class="btn" id="splitOnce" disabled title="每点一次完成一变，三变成一爻">分堆（下一变）</button>
        <button class="btn secondary" id="nextLine" disabled title="本爻完成后开始下一爻">开始下一爻</button>
        <button class="btn secondary" id="resetAll" title="从头再来">重开</button>

        <span style="flex:1"></span>
        <button class="btn prominent" id="methodBtn" aria-haspopup="dialog" aria-controls="methodModal" disabled>解卦（朱熹）</button>
      </div>

      <div id="status" class="muted small">未开始。点击“开始一卦”。</div>

      <div class="grid2" style="margin-top:12px">
        <div class="card" aria-label="当前爻">
          <div style="font-weight:600;margin-bottom:6px">当前爻（自下而上）</div>
          <div id="currInfo" class="small mono"></div>
          <pre id="currDetail" aria-live="polite"></pre>
        </div>
        <div class="card" aria-label="已成爻">
          <div style="font-weight:600;margin-bottom:6px">已成爻（从下而上实时堆叠）</div>
          <div id="builtLines" class="lines bottom-up"></div>
          <div class="small muted" id="builtText"></div>
        </div>
      </div>
    </div>

    <!-- 右：结果 -->
    <div class="card" aria-label="结果与链接">
      <div style="font-weight:600;margin-bottom:6px" id="labelMain">本卦</div>
      <div id="mainHex" class="lines"></div>
      <div class="small muted" id="triMain"></div>
      <div id="linksMain" class="small"></div>

      <div style="height:12px"></div>

      <div style="font-weight:600;margin-bottom:6px" id="labelRel">之卦</div>
      <div id="relHex" class="lines"></div>
      <div class="small muted" id="triRel"></div>
      <div id="linksRel" class="small"></div>

      <div class="toolbar">
        <label class="checkbox"><input type="checkbox" id="includeSteps"> 包含三变明细</label>
        <button class="btn small" id="copyBtn" disabled>复制结果</button>
        <span class="sep"></span>
      </div>

      <details class="hint">
        <summary>术语提示</summary>
        <div class="small" style="margin-top:6px">
          动爻＝6（老阴）/9（老阳）；阳爻＝7/9，阴爻＝6/8。之卦＝把动位翻转（6→阳、9→阴）。<br>
          互卦：取2-4与3-5为上下；错卦：阴阳互换；综卦：六爻倒置。<br>
          八卦（底→顶）：乾111、兑110、离101、震100、巽011、坎010、艮001、坤000。
        </div>
      </details>

      <div style="height:12px"></div>

      <div style="font-weight:600;margin-bottom:6px" title="互：取2-4与3-5为上下；错：阴阳倒换；综：六爻倒置">互卦 / 错卦 / 综卦（含卦名与二进制）</div>
      <div class="small mono" id="moreHex"></div>
    </div>
  </div>

  <!-- 自检 -->
  <div class="card" style="margin-top:16px" aria-label="分布自检">
    <div style="display:flex;gap:8px;align-items:flex-end;flex-wrap:wrap">
      <div style="flex:1;min-width:230px">
        <label for="N" class="small muted">分布自检样本量（建议 ≥ 100000）</label>
        <input id="N" type="number" value="100000" min="1000" step="1000" />
      </div>
      <button id="selftest" class="btn secondary">运行自检</button>
    </div>
    <div id="check" style="margin-top:12px;display:none">
      <div class="small muted">
        参考基准约
        <span class="mono">6≈6.25%，7≈31.25%，8≈43.75%，9≈18.75%</span>（仅作健康检查）。
      </div>
      <pre id="stat" class="mono" aria-live="polite"></pre>
      <div id="statWarn" class="small warn"></div>
    </div>
  </div>
</div>

<!-- 指南 -->
<div class="modal" id="guideModal" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
  <div class="box" tabindex="-1">
    <div id="guideTitle" class="title">指南 · 一看就会</div>
    <div class="hr"></div>
    <div class="small" style="line-height:1.85">
      <b>如何使用 · 带你走完一遍</b><br>
      1）想清楚问题；2）点<b>开始一卦</b>；3）每爻连点<b>分堆</b>三次（每变均“挂一”）；4）六爻成卦后点<b>解卦（朱熹）</b>按提示阅读；5）需要时<b>复制结果</b>交给 AI。
    </div>
    <div class="hr"></div>
    <div style="text-align:right">
      <button class="btn small" id="guideClose">关闭</button>
    </div>
  </div>
</div>

<!-- 解卦（朱熹） -->
<div class="modal" id="methodModal" role="dialog" aria-modal="true" aria-labelledby="methodTitle">
  <div class="box" tabindex="-1">
    <div id="methodTitle" class="title">如何解卦 · 朱熹法</div>
    <div class="hr"></div>
    <div id="methodSummary" class="small"></div>
    <div class="hr"></div>
    <div class="small muted">
      规则速记：① 六爻静读卦辞；② 一动读动爻；③ 二动两爻（以上爻为主）；④ 三动前十/后十；⑤ 四动读之卦两静爻；⑥ 五动读之卦唯一静爻；⑦ 六合（乾/坤）用九/用六，余读之卦卦辞。
    </div>
    <div style="text-align:right;margin-top:6px">
      <button class="btn small" id="methodClose">关闭</button>
    </div>
  </div>
</div>

<script>
/* ========= 版本与构建 ========= */
const APP_VERSION = "v5.2.0-zero";
let   BUILD_SHA256 = "";
const __appendVersionToCommit = true;

async function sha256Hex(s){ const enc=new TextEncoder(); const buf=await crypto.subtle.digest("SHA-256", enc.encode(s));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join(""); }
async function computeBuildHashOnce(){
  if (BUILD_SHA256) return BUILD_SHA256;
  BUILD_SHA256 = await sha256Hex(document.documentElement.outerHTML);
  return BUILD_SHA256;
}
function cryptoNonceHex(bytes=16){ const u=new Uint8Array(bytes); crypto.getRandomValues(u); return Array.from(u).map(b=>b.toString(16).padStart(2,"0")).join(""); }

/* ========= RNG（保留，可用于演示/自检；核心采样见下） ========= */
function cryptoRng(){ const u32=new Uint32Array(1); return ()=>{ crypto.getRandomValues(u32); return (u32[0]>>>0)/2**32; }; }
function randIntInclusive(rng,a,b){ const u=rng(); return Math.floor(u*(b-a+1))+a; }
function mulberry32(seed){ let t = seed >>> 0; return () => { t += 0x6D2B79F5; let r = Math.imul(t ^ (t >>> 15), (t | 1)); r ^= r + Math.imul(r ^ (r >>> 7), (r | 61)); return ((r ^ (r >>> 14)) >>> 0) / 4294967296; }; }
function newSeed32(){ const u=new Uint32Array(1); crypto.getRandomValues(u); return (u[0]>>>0)||1; }

/* ========= 无偏离散采样（WebCrypto 32bit + 拒绝采样） ========= */
function randUint32(){ const u=new Uint32Array(1); crypto.getRandomValues(u); return (u[0]>>>0); }
function uniformIndex(n){
  if(n<=0) throw new Error("uniformIndex n<=0");
  const MOD = 0x100000000;                 // 2^32
  const lim = MOD - (MOD % n);             // 可整除覆盖
  let x; do { x = randUint32(); } while (x >= lim);
  return x % n;
}
function choose(arr){ return arr[uniformIndex(arr.length)]; }

/* ========= 工具 ========= */
function rem4NonZero(x){ const r=x%4; return r===0?4:r; }

/* ========= 模4均匀切分（零偏差） =========
   先在 {0,1,2,3} 上等概率抽 A 的模4余数 r，
   再在 [1, total-1] 里无偏挑选满足 A≡r(mod4) 的 A；B=total-A。*/
function splitNonZero(total /*, rng（忽略）*/){
  const r = uniformIndex(4);                 // 0..3
  const start = (r===0 ? 4 : r);
  const Avals = [];
  for(let a=start; a<=total-1; a+=4) Avals.push(a);
  const A = Avals.length ? choose(Avals) : (1 + uniformIndex(total-1)); // 兜底
  return [A, total - A];
}

/* ========= 三变皆挂一 ========= */
function firstChange(n /*, rng*/){
  const [A,B] = splitNonZero(n);
  const leftRem  = rem4NonZero(A);
  const rightRem = rem4NonZero(B-1); // 先挂一
  const taken = 1 + leftRem + rightRem; // 5 或 9
  return { after:n-taken, step:{from:n,to:n-taken,A,B,leftRem,rightRem,taken,kind:"第1变（挂一）"} };
}
function nextChange(n /*, rng*/){
  const [A,B] = splitNonZero(n);
  const leftRem  = rem4NonZero(A);
  const rightRem = rem4NonZero(B-1); // 仍旧挂一
  const taken = 1 + leftRem + rightRem; // 4 或 8
  return { after:n-taken, step:{from:n,to:n-taken,A,B,leftRem,rightRem,taken,kind:"后续变（挂一）"} };
}

/* ========= 映射 ========= */
function remainingToLine(n){
  if(n===24) return 6;
  if(n===28) return 7;
  if(n===32) return 8;
  if(n===36) return 9;
  throw new Error("Unexpected remainder: "+n);
}
function genOneStep(n, idx /*, rng*/){ return (idx===1) ? firstChange(n) : nextChange(n); }
function genLineYarrow(/*rng*/){
  let n=49; const t1=firstChange(n); n=t1.after;
  const t2=nextChange(n); n=t2.after;
  const t3=nextChange(n); n=t3.after;
  return { value:remainingToLine(n) };
}

/* ========= 卦运算 ========= */
function isYang(v){ return v===7||v===9; }
function isMoving(v){ return v===6||v===9; }
function toBinary(lines){ return lines.map(v=>isYang(v)?1:0); } // 底→顶
function relatingFrom(lines){ const out=lines.slice(); for(let i=0;i<6;i++){ if(lines[i]===6) out[i]=7; else if(lines[i]===9) out[i]=8; } return out; }
function nuclearFromBinary(b){ return [b[1],b[2],b[3], b[2],b[3],b[4]]; }
function invertedFromBinary(b){ return [b[5],b[4],b[3],b[2],b[1],b[0]]; }
function oppositeFromBinary(b){ return b.map(x=>x?0:1); }

const TRIS = {"111":{zh:"乾",sym:"☰"},"110":{zh:"兑",sym:"☱"},"101":{zh:"离",sym:"☲"},"100":{zh:"震",sym:"☳"},
"011":{zh:"巽",sym:"☴"},"010":{zh:"坎",sym:"☵"},"001":{zh:"艮",sym:"☶"},"000":{zh:"坤",sym:"☷"}};
function triNameOf(b3){ const k=b3.join(""); return TRIS[k]?`${TRIS[k].sym}${TRIS[k].zh}`:k; }
function trisOf(bin){ const lower=bin.slice(0,3), upper=bin.slice(3,6); return {lower,upper}; }

const HEX64 = {
"111111":{no:1,zh:"乾",full:"乾为天"},"000000":{no:2,zh:"坤",full:"坤为地"},
"100010":{no:3,zh:"屯",full:"水雷屯"},"010001":{no:4,zh:"蒙",full:"山水蒙"},
"111010":{no:5,zh:"需",full:"水天需"},"010111":{no:6,zh:"讼",full:"天水讼"},
"010000":{no:7,zh:"师",full:"地水师"},"000010":{no:8,zh:"比",full:"水地比"},
"111011":{no:9,zh:"小畜",full:"风天小畜"},"110111":{no:10,zh:"履",full:"天泽履"},
"111000":{no:11,zh:"泰",full:"地天泰"},"000111":{no:12,zh:"否",full:"天地否"},
"101111":{no:13,zh:"同人",full:"天火同人"},"111101":{no:14,zh:"大有",full:"火天大有"},
"001000":{no:15,zh:"谦",full:"地山谦"},"000100":{no:16,zh:"豫",full:"雷地豫"},
"100110":{no:17,zh:"随",full:"泽雷随"},"011001":{no:18,zh:"蛊",full:"山风蛊"},
"110000":{no:19,zh:"临",full:"地泽临"},"000011":{no:20,zh:"观",full:"风地观"},
"100101":{no:21,zh:"噬嗑",full:"火雷噬嗑"},"101001":{no:22,zh:"贲",full:"山火贲"},
"000001":{no:23,zh:"剥",full:"山地剥"},"100000":{no:24,zh:"复",full:"地雷复"},
"100111":{no:25,zh:"无妄",full:"天雷无妄"},"111001":{no:26,zh:"大畜",full:"山天大畜"},
"100001":{no:27,zh:"颐",full:"山雷颐"},"011110":{no:28,zh:"大过",full:"泽风大过"},
"010010":{no:29,zh:"坎",full:"坎为水"},"101101":{no:30,zh:"离",full:"离为火"},
"001110":{no:31,zh:"咸",full:"泽山咸"},"011100":{no:32,zh:"恒",full:"雷风恒"},
"001111":{no:33,zh:"遯",full:"天山遯"},"111100":{no:34,zh:"大壮",full:"雷天大壮"},
"000101":{no:35,zh:"晋",full:"火地晋"},"101000":{no:36,zh:"明夷",full:"地火明夷"},
"101011":{no:37,zh:"家人",full:"风火家人"},"110101":{no:38,zh:"睽",full:"火泽睽"},
"001010":{no:39,zh:"蹇",full:"水山蹇"},"010100":{no:40,zh:"解",full:"雷水解"},
"110001":{no:41,zh:"损",full:"山泽损"},"100011":{no:42,zh:"益",full:"风雷益"},
"111110":{no:43,zh:"夬",full:"泽天夬"},"011111":{no:44,zh:"姤",full:"天风姤"},
"000110":{no:45,zh:"萃",full:"泽地萃"},"011000":{no:46,zh:"升",full:"地风升"},
"010110":{no:47,zh:"困",full:"泽水困"},"011010":{no:48,zh:"井",full:"水风井"},
"101110":{no:49,zh:"革",full:"泽火革"},"011101":{no:50,zh:"鼎",full:"火风鼎"},
"100100":{no:51,zh:"震",full:"震为雷"},"001001":{no:52,zh:"艮",full:"艮为山"},
"001011":{no:53,zh:"渐",full:"风山渐"},"110100":{no:54,zh:"归妹",full:"雷泽归妹"},
"101100":{no:55,zh:"丰",full:"雷火丰"},"001101":{no:56,zh:"旅",full:"火山旅"},
"011011":{no:57,zh:"巽",full:"巽为风"},"110110":{no:58,zh:"兑",full:"兑为泽"},
"010011":{no:59,zh:"涣",full:"风水涣"},"110010":{no:60,zh:"节",full:"水泽节"},
"110011":{no:61,zh:"中孚",full:"风泽中孚"},"001100":{no:62,zh:"小过",full:"雷山小过"},
"101010":{no:63,zh:"既济",full:"水火既济"},"010101":{no:64,zh:"未济",full:"火水未济"}
};
const TRIGRAM_ELEM = {"111":"天","110":"泽","101":"火","100":"雷","011":"风","010":"水","001":"山","000":"地"};
(function validateHexMap(){
  Object.entries(HEX64).forEach(([k,v])=>{
    if(!v || typeof v!=="object") return;
    const bits=k.split("").map(x=>x==="1"?1:0);
    const up=bits.slice(3,6).join(""), low=bits.slice(0,3).join("");
    HEX64[k]={...v, zh:v.zh||"", full:v.full||`${TRIGRAM_ELEM[up]||""}${TRIGRAM_ELEM[low]||""}${v.zh||""}`};
  });
})();
function hexInfoOf(bin){ const k=Array.isArray(bin)?bin.join(""):String(bin); return HEX64[k]||null; }
function hexLabel(bin){
  const key = Array.isArray(bin) ? bin.join("") : String(bin);
  const info = HEX64[key]; if(!info) return `未收录（${key}）`;
  const bits = Array.isArray(bin)?bin.slice():key.split("").map(x=>x==="1"?1:0);
  const up=bits.slice(3,6).join(""), low=bits.slice(0,3).join("");
  const short=info.zh||"", full=info.full||`${TRIGRAM_ELEM[up]||""}${TRIGRAM_ELEM[low]||""}${short}`;
  return `${info.no}. ${full}「${short}」`;
}

/* ========= UI refs ========= */
const $ = s=>document.querySelector(s);
const elStart=$("#startHex"), elSplit=$("#splitOnce"), elNextLine=$("#nextLine"), elReset=$("#resetAll");
const elStatus=$("#status");
const elCurrInfo=$("#currInfo"), elCurrDetail=$("#currDetail");
const elBuilt=$("#builtLines"), elBuiltText=$("#builtText");
const elMain=$("#mainHex"), elRel=$("#relHex"), elTriM=$("#triMain"), elTriR=$("#triRel"), elMore=$("#moreHex");
const elLabelMain=$("#labelMain"), elLabelRel=$("#labelRel");
const elVRS=$("#vrs"), verpill=$("#verpill");
const elN=$("#N"), elCheck=$("#check"), elStat=$("#stat"), elWarn=$("#statWarn");
const guideBtn=$("#guideBtn"), guideModal=$("#guideModal"), guideClose=$("#guideClose");
const methodBtn=$("#methodBtn"), methodModal=$("#methodModal"), methodClose=$("#methodClose"), methodSummary=$("#methodSummary");
const linksMain=$("#linksMain"), linksRel=$("#linksRel");
const copyBtn=$("#copyBtn"), includeSteps=$("#includeSteps");

/* ========= 渲染 ========= */
function renderOneLineVisual(v){
  const row=document.createElement("div"); row.className="one-line";
  const isY=(v===7||v===9), moving=(v===6||v===9);
  if(isY){ const bar=document.createElement("div"); bar.className="yang"; row.appendChild(bar); }
  else{ const yin=document.createElement("div"); yin.className="yin";
        yin.append(Object.assign(document.createElement("div"),{className:"seg"}),
                   Object.assign(document.createElement("div"),{className:"gap"}),
                   Object.assign(document.createElement("div"),{className:"seg"}));
        row.appendChild(yin); }
  const lab=document.createElement("div"); lab.className="small mono"; lab.textContent=String(v);
  if(moving){ const t=document.createElement("span"); t.className="tag"; t.textContent="动"; lab.appendChild(t); }
  row.appendChild(lab); return row;
}
function renderLines(container, lines){
  container.innerHTML=""; const visual=lines.slice().reverse(); visual.forEach(v=>container.appendChild(renderOneLineVisual(v)));
}
function renderBuilt(lines){
  elBuilt.innerHTML="";
  if(!lines.length){ elBuiltText.textContent="尚无成爻。"; return; }
  lines.forEach(v=> elBuilt.appendChild(renderOneLineVisual(v)));
  elBuiltText.textContent = `（已成 ${lines.length}/6 爻；从下而上：${lines.join(", ")}）`;
}
function trisOfBin(bin){ const lower=bin.slice(0,3), upper=bin.slice(3,6); return {lower,upper}; }
function renderTris(el, bin){
  const {lower,upper}=trisOfBin(bin);
  el.textContent=`下卦：${triNameOf(lower)}　上卦：${triNameOf(upper)}　（二进制 底→顶：${bin.join("")})`;
}
function renderMore(el,bMain){
  const bNuc=nuclearFromBinary(bMain), bOpp=oppositeFromBinary(bMain), bInv=invertedFromBinary(bMain);
  const line=(label,b)=>`${label}：${triNameOf(b.slice(0,3))}/${triNameOf(b.slice(3,6))}  ${b.join("")} ｜ ${hexLabel(b)}`;
  el.textContent=[ line("互卦",bNuc), line("错卦",bOpp), line("综卦",bInv) ].join("\n");
}

/* ========= 外部链接 ========= */
const CN_POS = ["初","二","三","四","五","上"];
function buildLinks(targetEl, binArr, sourceLinesForMoving, opts = {}){
  const bin = Array.isArray(binArr) ? binArr : String(binArr).split("").map(x=>x==="1"?1:0);
  const info = hexInfoOf(bin.join(""));
  targetEl.innerHTML = "";
  if(!info) return;

  const name = info.zh;
  const t=document.createElement("div");
  t.className="small muted";
  t.textContent="查原文 / 注疏（外部）：";
  targetEl.appendChild(t);
  const q = encodeURIComponent("周易 "+name);
  const links = [
    { t:"维基(中文)", url:`https://zh.wikipedia.org/w/index.php?search=${q}` },
    { t:"维基文库",    url:`https://zh.wikisource.org/w/index.php?search=${q}` },
    { t:"CTP",         url:`https://ctext.org/zh?searchu=${q}` },
    { t:"百度",        url:`https://www.baidu.com/s?wd=${q}` },
    { t:"Bing",        url:`https://www.bing.com/search?q=${q}` },
  ];
  const box=document.createElement("div");
  links.forEach(L=>{
    const a=document.createElement("a");
    a.className="linkchip";
    a.href=L.url; a.target="_blank"; a.rel="noopener noreferrer";
    a.textContent=L.t;
    box.appendChild(a);
  });
  targetEl.appendChild(box);

  if (Array.isArray(sourceLinesForMoving) && sourceLinesForMoving.some(isMoving)){
    const tip=document.createElement("div");
    tip.className="small muted"; tip.style.marginTop="6px";
    tip.textContent = opts.movingLabel || "动爻直达：";
    targetEl.appendChild(tip);

    const b2=document.createElement("div");
    sourceLinesForMoving.forEach((v,i)=>{
      if(isMoving(v)){
        const yao=(v===9)?"九":"六";
        const pos=CN_POS[i];
        const qq=encodeURIComponent(`周易 ${name} ${yao}${pos} 爻辞`);
        const a=document.createElement("a");
        a.className="linkchip";
        a.href=`https://www.bing.com/search?q=${qq}`;
        a.target="_blank"; a.rel="noopener noreferrer";
        a.textContent=`${yao}${pos}`;
        b2.appendChild(a);
      }
    });
    targetEl.appendChild(b2);
  }

  if (opts.staticIndices && opts.staticIndices.length){
    const tip=document.createElement("div");
    tip.className="small muted"; tip.style.marginTop="6px";
    tip.textContent = opts.staticLabel || "静爻直达：";
    targetEl.appendChild(tip);

    const b3=document.createElement("div");
    opts.staticIndices.forEach(i=>{
      const yao = (bin[i-1]===1) ? "九" : "六";
      const pos = CN_POS[i-1];
      const qq  = encodeURIComponent(`周易 ${name} ${yao}${pos} 爻辞`);
      const a   = document.createElement("a");
      a.className="linkchip";
      a.href=`https://www.bing.com/search?q=${qq}`;
      a.target="_blank"; a.rel="noopener noreferrer";
      a.textContent = `${yao}${pos}`;
      b3.appendChild(a);
    });
    targetEl.appendChild(b3);
  }
}

/* ========= 状态 ========= */
const state = { rng: cryptoRng(), sessionNonce: "", lines: [], hexDetail: [], curr: null, finished: false };

/* ========= 导出 ========= */
function buildExportText(includeDetails){
  if(!state.finished) return "（尚未完成六爻，无法导出）";
  const ts = new Date().toLocaleString();
  const mainBin = toBinary(state.lines);
  const relating = relatingFrom(state.lines);
  const binRel = toBinary(relating);
  const mainLbl = hexLabel(mainBin);
  const relLbl  = hexLabel(binRel);
  const {lower:lm, upper:um} = trisOfBin(mainBin);
  const {lower:lr, upper:ur} = trisOfBin(binRel);
  const movIdx = state.lines.map((v,i)=> (v===6||v===9)? i+1 : null).filter(Boolean);
  const movTxt = movIdx.length? ("第 "+movIdx.join("、")+" 爻") : "（无）";

  let s = "";
  s += `大衍筮法 · 起卦结果\n`;
  s += `时间：${ts}\n版本：${APP_VERSION}\nVRS：${document.getElementById("vrs").textContent}\n`;
  s += `——\n`;
  s += `本卦：${mainLbl}｜二进制：${mainBin.join("")}｜下卦：${triNameOf(lm)} 上卦：${triNameOf(um)}\n`;
  s += `之卦：${relLbl}｜二进制：${binRel.join("")}｜下卦：${triNameOf(lr)} 上卦：${triNameOf(ur)}\n`;
  const bNuc=nuclearFromBinary(mainBin), bOpp=oppositeFromBinary(mainBin), bInv=invertedFromBinary(mainBin);
  s += `互卦：${hexLabel(bNuc)}｜错卦：${hexLabel(bOpp)}｜综卦：${hexLabel(bInv)}\n`;
  s += `——\n`;
  s += `六爻（自下而上）：${state.lines.join(", ")}；动爻：${movTxt}\n`;
  return s;
}

/* ========= 基本流程 ========= */
function resetAll(){
  state.rng = cryptoRng(); state.sessionNonce = ""; state.lines = []; state.hexDetail = []; state.curr = null; state.finished = false;
  elStatus.textContent = "未开始。点击“开始一卦”。";
  elCurrInfo.textContent = ""; elCurrDetail.textContent = "";
  elMain.innerHTML = elRel.innerHTML = elMore.textContent = ""; elTriM.textContent = elTriR.textContent = "";
  linksMain.innerHTML = linksRel.innerHTML = ""; elLabelMain.textContent="本卦"; elLabelRel.textContent="之卦";
  methodBtn.disabled = true; copyBtn.disabled = true;
  renderBuilt(state.lines); elSplit.disabled = elNextLine.disabled = true;
}
function startHex(){
  state.sessionNonce = cryptoNonceHex(16); state.lines = []; state.hexDetail = []; state.finished = false;
  startNewLine(); elStatus.innerHTML = `已开始本卦。<span class="ok">当前爻：第 ${state.lines.length+1} 爻（自下而上）</span>`;
}
function startNewLine(){
  state.curr = { n:49, stepIdx:1, steps:[], done:false };
  updateCurrUI(); elSplit.disabled = false; elNextLine.disabled = true;
}
function updateCurrUI(){
  if(!state.curr){ elCurrInfo.textContent=""; elCurrDetail.textContent=""; return; }
  const idx = state.lines.length + (state.curr.done?0:1);
  const nextHint = state.curr.done ? "（本爻已成）" : (state.curr.stepIdx===1?"第1变（先挂一）":"第"+state.curr.stepIdx+"变");
  elCurrInfo.textContent = `当前爻：第 ${idx} 爻｜现有蓍草数 n=${state.curr.n}｜${ state.curr.done ? "三变明细如下" : "下一步："+nextHint }`;
  const display = state.curr.steps.map((s,i)=>({ 变序:i+1, 从:s.from, 到:s.to, A:s.A, B:s.B, 左余:s.leftRem, 右余:s.rightRem, 取走:s.taken, 标注:s.kind }));
  elCurrDetail.textContent = display.length ? JSON.stringify(display, null, 2) : "（等待分堆）";
}
function doOneSplit(){
  const {n, stepIdx} = state.curr;
  const {after, step} = genOneStep(n, stepIdx);
  step.idx = stepIdx; state.curr.steps.push(step); state.curr.n = after; state.curr.stepIdx++;

  if (state.curr.stepIdx===4){
    if (![24,28,32,36].includes(state.curr.n)){
      elStatus.innerHTML = `<span class="warn">分堆异常：剩余 n=${state.curr.n}（应为 24/28/32/36）。请点击“重开”。</span>`;
      elSplit.disabled = true; elNextLine.disabled = true; return;
    }
    const value = remainingToLine(state.curr.n);
    state.lines.push(value);
    state.hexDetail.push({ line: state.lines.length, value, remainder: state.curr.n, steps: state.curr.steps.slice() });

    renderBuilt(state.lines);

    const idx = state.lines.length;
    elStatus.innerHTML = `第 ${idx} 爻已成：<b>${value}</b>（${(value===7||value===9)?"阳":"阴"}${(value===6||value===9)?"·动":""}）。`;
    state.curr.done = true;
    updateCurrUI();

    elSplit.disabled = true;
    if (state.lines.length < 6){
      elNextLine.disabled = false;
    }else{
      elNextLine.disabled = true;
      finishHex();
    }
  }else{
    updateCurrUI();
  }
}

/* ========= 完成一卦 ========= */
async function finishHex(){
  const binMain = toBinary(state.lines);
  const relating = relatingFrom(state.lines);
  const binRel  = toBinary(relating);

  renderLines(elMain, state.lines);
  renderLines(elRel, relating);
  renderTris(elTriM, binMain);
  renderTris(elTriR, binRel);
  elLabelMain.textContent = `本卦：` + hexLabel(binMain);
  elLabelRel.textContent  = `之卦：` + hexLabel(binRel);

  const movIdx = state.lines.map((v,i)=> (v===6||v===9)? i+1 : null).filter(Boolean);
  let staticOnRel = [];
  if (movIdx.length === 4 || movIdx.length === 5){
    staticOnRel = [1,2,3,4,5,6].filter(i => !movIdx.includes(i));
  }

  buildLinks(linksMain, toBinary(state.lines), state.lines);
  buildLinks(linksRel, toBinary(relating), undefined, { staticIndices: staticOnRel, staticLabel: "静爻直达（之卦）" });

  const bNuc = nuclearFromBinary(binMain);
  const bOpp = oppositeFromBinary(binMain);
  const bInv = invertedFromBinary(binMain);
  const line = (label,b)=>`${label}：${triNameOf(b.slice(0,3))}/${triNameOf(b.slice(3,6))}  ${b.join("")} ｜ ${hexLabel(b)}`;
  document.getElementById("moreHex").textContent = [ line("互卦",bNuc), line("错卦",bOpp), line("综卦",bInv) ].join("\n");

  state.finished = true;

  await computeBuildHashOnce();
  const epochMs = Date.now();
  const bodyHash = await sha256Hex(JSON.stringify({lines:state.lines, detail:state.hexDetail}));
  const commitStr = (__appendVersionToCommit ? `${APP_VERSION}|${BUILD_SHA256}|` : "") + `nonce:${state.sessionNonce}|t:${epochMs}|body:${bodyHash}`;
  elVRS.textContent = (await sha256Hex(commitStr)).slice(0,16)+"…";

  methodBtn.disabled = false;
  copyBtn.disabled = false;
  elStatus.innerHTML = `<span class="ok">全卦完成。</span> 可点<b>解卦（朱熹）</b>查看判读路径，或<b>复制结果</b>保存/分享。`;
}

/* ========= 自检 ========= */
function pct(n,d){ return (n/d*100).toFixed(3)+"%"; }
document.getElementById("selftest").addEventListener("click", ()=>{
  const N = Math.max(1000, parseInt(elN.value,10)||100000);
  const cnt = {6:0,7:0,8:0,9:0};
  for(let i=0;i<N;i++){ const { value } = genLineYarrow(); cnt[value]++; }
  elStat.textContent =
    `样本数 N = ${N}\n`+
    `计数：${JSON.stringify(cnt)}\n`+
    `比例：{6:${pct(cnt[6],N)}, 7:${pct(cnt[7],N)}, 8:${pct(cnt[8],N)}, 9:${pct(cnt[9],N)}}\n`+
    `参考基准：{6:≈6.25%, 7:≈31.25%, 8:≈43.75%, 9:≈18.75%}`;
  const trendOK=(cnt[8]>=cnt[7])&&(cnt[7]>=cnt[9])&&(cnt[9]>=cnt[6]); // 8 ≥ 7 ≥ 9 ≥ 6
  elStat.textContent += `\n趋势检查：${ trendOK ? "近似符合（8 ≥ 7 ≥ 9 ≥ 6）" : "偏离较大（建议增大样本或检查实现）" }`;
  document.getElementById("check").style.display="block";
  elWarn.textContent = (N<50000) ? "提示：样本量较小，波动较大；建议 ≥ 100000。" : "";
});

/* ========= 事件 ========= */
elStart.addEventListener("click", ()=> startHex());
elSplit.addEventListener("click", ()=>{ if(state.curr) doOneSplit(); });
elNextLine.addEventListener("click", ()=>{ if(!state.curr || state.curr.done){ startNewLine(); elStatus.innerHTML = `继续起卦。当前爻：第 ${state.lines.length+1} 爻（自下而上）`; } });
elReset.addEventListener("click", ()=> resetAll());

const guideBtnEl=document.getElementById("guideBtn"), guideModalEl=document.getElementById("guideModal"), guideCloseEl=document.getElementById("guideClose");
guideBtnEl.addEventListener("click", ()=>{ guideModalEl.style.display="block"; setTimeout(()=>guideModalEl.querySelector(".box").focus(),0); });
guideCloseEl.addEventListener("click", ()=>{ guideModalEl.style.display="none"; guideBtnEl?.focus(); });
guideModalEl.addEventListener("click", (e)=>{ if(e.target===guideModalEl) { guideModalEl.style.display="none"; guideBtnEl?.focus(); } });
document.addEventListener("keydown",(e)=>{ if(guideModalEl.style.display==="block" && e.key==="Escape") { guideModalEl.style.display="none"; guideBtnEl?.focus(); } });

const methodBtnEl=document.getElementById("methodBtn"), methodModalEl=document.getElementById("methodModal"), methodCloseEl=document.getElementById("methodClose");
methodBtnEl.addEventListener("click", ()=>{ methodModalEl.style.display="block"; setTimeout(()=>methodModalEl.querySelector(".box").focus(),0); });
methodCloseEl.addEventListener("click", ()=>{ methodModalEl.style.display="none"; methodBtnEl?.focus(); } });
methodModalEl.addEventListener("click", (e)=>{ if(e.target===methodModalEl) { methodModalEl.style.display="none"; methodBtnEl?.focus(); } });
document.addEventListener("keydown",(e)=>{ if(methodModalEl.style.display==="block" && e.key==="Escape") { methodModalEl.style.display="none"; methodBtnEl?.focus(); } });

/* ========= 初始化 ========= */
(async function init(){
  await computeBuildHashOnce();
  document.getElementById("verpill").textContent = APP_VERSION+" · "+(BUILD_SHA256||"").slice(0,8)+"…";
  resetAll();
})();
</script>
</body>
</html>
